{% extends 'base/layout.html' %}
{% load static %}

{% block title %}Terminal - {{ device }}{% endblock %}

{% block extra_styles %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.1.0/css/xterm.css" />
<style>
    #terminal-card-body {
        height: 75vh;
        background-color: #000;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        padding: 0 !important;
        border-radius: 0 0 4px 4px;
    }

    #terminal-header {
        background-color: #1e1e1e;
        color: #fff;
        padding: 10px 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #333;
        flex-shrink: 0;
    }

    #terminal-header .device-info {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    #terminal-header .status-badge {
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
    }

    #terminal-header .status-badge.connected {
        background-color: #10b981;
        color: #fff;
    }

    #terminal-header .status-badge.connecting {
        background-color: #f59e0b;
        color: #fff;
    }

    #terminal-header .status-badge.disconnected {
        background-color: #ef4444;
        color: #fff;
    }

    #terminal-header .status-badge.error {
        background-color: #dc2626;
        color: #fff;
    }

    #terminal-container {
        flex: 1;
        width: 100%;
        background-color: #000;
        margin: 0;
        padding: 0;
        overflow: hidden;
        position: relative;
    }

    .xterm {
        position: absolute !important;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        padding: 4px;
    }

    .xterm .xterm-viewport {
        overflow-y: auto !important;
        background-color: #000 !important;
    }

    .xterm .xterm-viewport::-webkit-scrollbar {
        width: 8px;
    }

    .xterm .xterm-viewport::-webkit-scrollbar-track {
        background: #000;
    }

    .xterm .xterm-viewport::-webkit-scrollbar-thumb {
        background: #333;
        border-radius: 4px;
    }

    .xterm .xterm-viewport::-webkit-scrollbar-thumb:hover {
        background: #444;
    }

    .btn-terminal {
        padding: 4px 12px;
        font-size: 12px;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        transition: all 0.2s;
    }

    .btn-terminal-reconnect {
        background-color: #3b82f6;
        color: #fff;
    }

    .btn-terminal-reconnect:hover {
        background-color: #2563eb;
    }

    .btn-terminal-reconnect:disabled {
        background-color: #6b7280;
        cursor: not-allowed;
    }

    .btn-terminal-close {
        background-color: #ef4444;
        color: #fff;
    }

    .btn-terminal-close:hover {
        background-color: #dc2626;
    }
</style>
{% endblock %}

{% block content %}
<div class="row justify-content-center">
    <div class="col col-12 col-lg-11">
        <div class="card">
            <div id="terminal-card-body" class="card-body">
                <div id="terminal-header">
                    <div class="device-info">
                        <i class="mdi mdi-console"></i>
                        <strong>{{ device }}</strong>
                        {% if device_ip %}
                        <span class="text-muted small">({{ device_ip }})</span>
                        {% endif %}
                        <span id="connection-status" class="status-badge disconnected">Disconnected</span>
                    </div>
                    <div class="terminal-controls">
                        <button id="btn-reconnect" class="btn-terminal btn-terminal-reconnect">
                            <i class="mdi mdi-refresh"></i> Reconnect
                        </button>
                        <button id="btn-close" class="btn-terminal btn-terminal-close">
                            <i class="mdi mdi-close"></i> Close
                        </button>
                    </div>
                </div>
                <div id="terminal-container"></div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block javascript %}
{% if not error %}
<script src="https://cdn.jsdelivr.net/npm/xterm@5.1.0/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.js"></script>

<script>
(function() {
    'use strict';

    class WebTerminal {
        constructor(deviceId, username, password) {
            this.deviceId = deviceId;
            this.username = username;
            this.password = password;
            this.socket = null;
            this.term = null;
            this.fitAddon = null;
            this.resizeObserver = null;
            this.resizeTimeout = null;
            this.userScrolledUp = false;
            this.isConnected = false;
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            this.maxReconnectAttempts = 3;
            this.reconnectDelay = 2000;
            
            this.statusElement = document.getElementById('connection-status');
            this.reconnectBtn = document.getElementById('btn-reconnect');
            this.closeBtn = document.getElementById('btn-close');
            
            this.init();
        }

        async init() {
            try {
                await this.initTerminal();
                this.setupEventListeners();
                this.connect();
            } catch (error) {
                console.error('Terminal initialization failed:', error);
                this.updateStatus('error', 'Initialization Error');
            }
        }

        async initTerminal() {
            this.term = new Terminal({
                cursorBlink: true,
                cursorStyle: 'block',
                fontFamily: 'Consolas, "Liberation Mono", Menlo, Courier, monospace',
                fontSize: 14,
                lineHeight: 1.2,
                letterSpacing: 0,
                scrollback: 5000,
                tabStopWidth: 4,
                theme: {
                    background: '#000000',
                    foreground: '#ffffff',
                    cursor: '#ffffff',
                    cursorAccent: '#000000',
                    selection: 'rgba(255, 255, 255, 0.3)',
                    black: '#000000',
                    red: '#cd3131',
                    green: '#0dbc79',
                    yellow: '#e5e510',
                    blue: '#2472c8',
                    magenta: '#bc3fbc',
                    cyan: '#11a8cd',
                    white: '#e5e5e5',
                    brightBlack: '#666666',
                    brightRed: '#f14c4c',
                    brightGreen: '#23d18b',
                    brightYellow: '#f5f543',
                    brightBlue: '#3b8eea',
                    brightMagenta: '#d670d6',
                    brightCyan: '#29b8db',
                    brightWhite: '#ffffff'
                },
                allowProposedApi: true,
                rightClickSelectsWord: true,
                wordSeparator: ' ()[]{}\'"`$'
            });

            this.fitAddon = new FitAddon.FitAddon();
            this.term.loadAddon(this.fitAddon);

            const container = document.getElementById('terminal-container');
            this.term.open(container);

            this.term.onScroll(() => {
                this.userScrolledUp = this.term.buffer.active.viewportY > 0;
            });

            this.term.onData((data) => {
                this.sendData(data);
            });

            this.term.onResize((size) => {
                this.sendResize(size);
            });

            await this.waitForFonts();
            await this.waitForLayout();
            this.fitAddon.fit();
        }

        waitForFonts() {
            return new Promise((resolve) => {
                if (document.fonts) {
                    document.fonts.ready.then(() => {
                        requestAnimationFrame(() => resolve());
                    });
                } else {
                    setTimeout(resolve, 100);
                }
            });
        }

        waitForLayout() {
            return new Promise((resolve) => {
                let attempts = 0;
                const checkLayout = () => {
                    attempts++;
                    if (this.term.cols > 0 && this.term.rows > 0) {
                        resolve();
                    } else if (attempts < 10) {
                        requestAnimationFrame(checkLayout);
                    } else {
                        resolve();
                    }
                };
                setTimeout(checkLayout, 50);
            });
        }

        setupEventListeners() {
            this.reconnectBtn.addEventListener('click', () => {
                if (!this.isConnecting) {
                    this.connect();
                }
            });

            this.closeBtn.addEventListener('click', () => {
                this.disconnect();
                window.close();
            });

            window.addEventListener('beforeunload', () => {
                this.disconnect();
            });

            window.addEventListener('resize', () => {
                this.debouncedResize();
            });

            this.resizeObserver = new ResizeObserver(() => {
                this.debouncedResize();
            });
            this.resizeObserver.observe(document.getElementById('terminal-container'));
        }

        debouncedResize() {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = setTimeout(() => {
                this.handleResize();
            }, 150);
        }

        handleResize() {
            if (!this.term || !this.fitAddon) return;

            try {
                this.fitAddon.fit();
                if (this.isConnected && this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.sendResize({ cols: this.term.cols, rows: this.term.rows });
                }
            } catch (error) {
                console.warn('Resize failed:', error);
            }
        }

        connect() {
            if (this.isConnecting || this.isConnected) return;

            this.isConnecting = true;
            this.updateStatus('connecting', 'Connecting...');
            this.reconnectBtn.disabled = true;

            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            let wsUrl = protocol + window.location.host + '/ws/terminal/' + this.deviceId + '/';

            const params = new URLSearchParams();
            if (this.username) params.append('username', this.username);
            if (this.password) params.append('password', this.password);
            params.append('rows', this.term.rows);
            params.append('cols', this.term.cols);

            const queryString = params.toString();
            if (queryString) wsUrl += '?' + queryString;

            this.socket = new WebSocket(wsUrl);
            this.socket.binaryType = 'arraybuffer';

            this.socket.onopen = () => {
                this.isConnected = true;
                this.isConnecting = false;
                this.reconnectAttempts = 0;
                this.updateStatus('connected', 'Connected');
                this.reconnectBtn.disabled = false;
                this.term.focus();
                this.sendResize({ cols: this.term.cols, rows: this.term.rows });
            };

            this.socket.onmessage = (event) => {
                this.handleMessage(event);
            };

            this.socket.onclose = (event) => {
                this.handleClose(event);
            };

            this.socket.onerror = (error) => {
                this.handleError(error);
            };
        }

        handleMessage(event) {
            let text = '';
            
            if (typeof event.data === 'string') {
                try {
                    const data = JSON.parse(event.data);
                    text = data.message || event.data;
                } catch (e) {
                    text = event.data;
                }
            } else {
                const buffer = event.data instanceof ArrayBuffer ? 
                    event.data : 
                    new Uint8Array(event.data);
                const decoder = new TextDecoder('utf-8');
                text = decoder.decode(buffer, { stream: true });
            }

            this.term.write(text);

            if (!this.userScrolledUp) {
                this.term.scrollToBottom();
            }
        }

        handleClose(event) {
            this.isConnected = false;
            this.isConnecting = false;
            this.updateStatus('disconnected', 'Disconnected');
            
            this.term.write('\r\n\x1b[1;31m[Connection Closed]\x1b[0m\r\n');
            this.term.options.cursorBlink = false;
            this.term.options.disableStdin = true;

            if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
                this.reconnectAttempts++;
                setTimeout(() => {
                    this.connect();
                }, this.reconnectDelay);
            } else {
                this.reconnectBtn.disabled = false;
            }
        }

        handleError(error) {
            console.error('WebSocket error:', error);
            this.updateStatus('error', 'Connection Error');
            this.term.write('\r\n\x1b[1;31m[Connection Error]\x1b[0m\r\n');
        }

        disconnect() {
            if (this.socket) {
                this.socket.close(1000, 'User disconnected');
            }
            if (this.resizeObserver) {
                this.resizeObserver.disconnect();
            }
            if (this.term) {
                this.term.dispose();
            }
            this.isConnected = false;
            this.isConnecting = false;
        }

        sendData(data) {
            if (this.isConnected && this.socket && this.socket.readyState === WebSocket.OPEN) {
                try {
                    this.socket.send(JSON.stringify({ data: data }));
                } catch (error) {
                    console.error('Send data error:', error);
                }
            }
        }

        sendResize(size) {
            if (this.isConnected && this.socket && this.socket.readyState === WebSocket.OPEN) {
                try {
                    this.socket.send(JSON.stringify({ 
                        resize: { 
                            rows: size.rows, 
                            cols: size.cols 
                        } 
                    }));
                } catch (error) {
                    console.error('Send resize error:', error);
                }
            }
        }

        updateStatus(status, text) {
            this.statusElement.className = 'status-badge ' + status;
            this.statusElement.textContent = text;
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        const deviceId = {{ device.pk }};
        const username = '{{ ssh_username|escapejs }}';
        const password = '{{ ssh_password|escapejs }}';
        
        new WebTerminal(deviceId, username, password);
    });
})();
</script>
{% endif %}
{% endblock %}
